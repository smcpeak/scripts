#!/usr/bin/env python3

import argparse
import subprocess
import re
import sys
from typing import List, Dict

# Regex patterns to ignore
IGNORE_REGEXPS: List[str] = [
  r"gcov-ignore",
  r"xfailure",
  r"xunimp",
  r"abort\s*\(",
  r"assert\s*\(\s*!\s*\"",
  r"av_failure",
  r"av_abort",
  r"fprintf\s*\(\s*stderr\s*,",
  r"silence warning",
  r"[nN]ot reached",
  r"ASTCASE",
  r"ASTNEXT",
  r"ASTDEFAULT",
  r"ASTENDCASE",
  r"catch\s*\(",
  r"^\s*default:$",
]


def kill_hashes(exec_count: str) -> str:
  if "#" in exec_count or "=" in exec_count:
    return " " * (len(exec_count) - 1) + "0"
  return exec_count


def should_ignore_line(code_line: str) -> bool:
  return any(re.search(regex, code_line) for regex in IGNORE_REGEXPS)


def is_explicit_filename(fname: str, filename_table: Dict[str, bool]) -> bool:
  return fname in filename_table


def should_show_report(fname: str, quiet: bool, filename_table: Dict[str, bool]) -> bool:
  return not quiet or is_explicit_filename(fname, filename_table)


def main() -> int:
  parser = argparse.ArgumentParser(
    description="Run gcov and filter its output to remove ignorable lines."
  )
  parser.add_argument(
    "-q",
    action="store_true",
    help="only print stats for explicitly named filenames",
  )
  parser.add_argument(
    "--object-directory",
    metavar="DIR",
    default="",
    help="look for gcno/gcda files in DIR",
  )
  parser.add_argument(
    "--require100",
    action="store_true",
    help="require 100%% coverage of listed files",
  )
  parser.add_argument(
    "filenames",
    nargs="+",
    help="source files to run gcov on",
  )

  args = parser.parse_args()

  quiet: bool = args.q
  object_directory: str = args.object_directory
  require100: bool = args.require100
  filenames: List[str] = args.filenames

  filename_table: Dict[str, bool] = {f + ".gcov": True for f in filenames}
  files_missing_coverage: List[str] = []

  gcov_command: List[str] = ["gcov"]
  if object_directory:
    gcov_command.extend(["--object-directory", object_directory])
  gcov_command.extend(filenames)

  print(" ".join(gcov_command))

  try:
    proc = subprocess.run(
      gcov_command, check=False, text=True, capture_output=True
    )
  except Exception as e:
    sys.exit(f"cannot exec gcov: {e}")

  gcov_output: List[str] = proc.stdout.splitlines()

  if proc.returncode != 0:
    return proc.returncode

  unexpected: List[str] = [line for line in gcov_output if line.startswith("Unexpected")]
  if unexpected:
    print("\n".join(unexpected))
    print("(perhaps you need to recompile?)")
    return 4

  for line in gcov_output:
    m = re.match(r"^Creating '(.*)'", line)
    if m:
      fname: str = m.group(1)

      try:
        with open(fname, "r") as f:
          input_lines: List[str] = f.readlines()
      except Exception as e:
        sys.exit(f"cannot read {fname}: {e}")

      lines: int = 0
      hit: int = 0
      output_line_num: int = 0
      ignoring: int = 0
      source_line_num: int = -1
      ignore_exn_lines: bool = False

      output: List[str] = []

      for text in input_lines:
        output_line_num += 1
        text = text.rstrip("\n")

        if text.startswith("---") or re.match(r"^\S+:$", text):
          continue

        m = re.match(
          r"^(\s*)([0-9#=-]+)(\*?):(\s*)([0-9]+):(.*)$", text
        )
        if not m:
          sys.exit(
            f"mygcov: {fname}:{output_line_num}: line not in expected format: \"{text}\""
          )

        pad1, exec_count, unexec_bb, pad2, code_line_number_str, code_line = m.groups()
        code_line_number: int = int(code_line_number_str)

        if code_line_number <= source_line_num:
          continue
        elif code_line_number == source_line_num + 1:
          source_line_num = code_line_number
        else:
          sys.exit(
            f"mygcov: {fname}:{output_line_num}: was expecting to see info about "
            f"line {source_line_num + 1}: \"{text}\""
          )

        if ignoring:
          if "gcov-end-ignore" in code_line:
            ignoring -= 1
          exec_count = kill_hashes(exec_count)
        elif "gcov-begin-ignore" in code_line:
          ignoring += 1
          exec_count = kill_hashes(exec_count)
        elif should_ignore_line(code_line):
          exec_count = kill_hashes(exec_count)
        elif "gcov-exception-lines-ignore" in code_line:
          ignore_exn_lines = True
        elif re.search(r"\d", exec_count):
          lines += 1
          hit += 1
        elif "#" in exec_count:
          lines += 1
        elif "=" in exec_count:
          if ignore_exn_lines:
            exec_count = kill_hashes(exec_count)
          else:
            lines += 1
        elif exec_count == "-":
          pass
        else:
          print(
            f"{fname}:{output_line_num}: execution count not understood: {exec_count}",
            file=sys.stderr,
          )

        output.append(
          f"{pad1}{exec_count}{unexec_bb}:{pad2}{code_line_number}:{code_line}"
        )

      with open(fname, "w") as f:
        for line_out in output:
          f.write(line_out + "\n")

      if should_show_report(fname, quiet, filename_table):
        pct: float = (hit / lines * 100.0) if lines else 0.0
        print(f"{pct:7.2f}% = {hit:5d} of {lines:5d} lines: {fname}")

        if (
          is_explicit_filename(fname, filename_table)
          and require100
          and hit < lines
        ):
          files_missing_coverage.append(fname)

  if files_missing_coverage:
    print("The following files do not have 100% coverage:")
    for fname in files_missing_coverage:
      print(f"  {fname}")
    return 2

  return 0


if __name__ == "__main__":
  sys.exit(main())
